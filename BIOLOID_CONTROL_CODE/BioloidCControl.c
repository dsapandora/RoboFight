/*
 * BioloidCControl.c - Replacement firmware for the Robotis Bioloid CM-510 controller
 *   and Bioloid Premium Kit based humanoid robots (Type A/B/C). 
 * 
 * Requires a motion.h file generated by the translate_motion.pl Perl script.
 *
 * Supports all motions, including walking, gyro, DMS, buzzer, LEDs, buttons and
 * serial connection via cable and ZIG2Serial.
 *   
 * Performs initializations and then runs main control loop
 *   
 * Version 0.5		31/10/2011 - finite state machine based control loop
 *
 * Written by Peter Lanius
 * Please send suggestions and bug fixes to PeterLanius@gmail.com
 *
 */

/*
 * You may freely modify and share this code, as long as you keep this
 * notice intact. Licensed under the Creative Commons BY-SA 3.0 license:
 *
 *   http://creativecommons.org/licenses/by-sa/3.0/
 *
 * Disclaimer: To the extent permitted by law, this work is provided
 * without any warranty. It might be defective, in which case you agree
 * to be responsible for all resulting costs and damages.
 */

#include <avr/io.h>
#include <stdio.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include "global.h"			// modify settings for your robot here
#include "buzzer.h"
#include "button.h"
#include "led.h"
#include "serial.h"			// contains the command strings recognised
#include "adc.h"
#include "dynamixel.h"
#include "pose.h"
#include "motion_f.h"
#include "clock.h"
#include "walk.h"

// Array showing which Dynamixel servos are enabled (ID from 0 to 25)
#ifdef HUMANOID_TYPEA
  const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
  const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18};
#endif
#ifdef HUMANOID_TYPEB
  const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
  const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,7,8,11,12,13,14,15,16,17,18};
#endif
#ifdef HUMANOID_TYPEC
  const uint8 AX12Servos[MAX_AX12_SERVOS] = {0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0}; 
  const uint8 AX12_IDS[NUM_AX12_SERVOS] = {1,2,3,4,5,6,9,10,11,12,13,14,15,16,17,18};
#endif

// store the buzzer melodies in Flash
const char melody1[] PROGMEM = "!L16 cdefgab>cbagfedc";
const char melody2[] PROGMEM = "T240 L8 a gafaeada c+adaeafa";
const char melody3[] PROGMEM = "O6 T40 L16 d#<b<f#<d#<f#<bd#f#";
const char melody4[] PROGMEM = "! O6 L16 dcd<b-d<ad<g d<f+d<gd<ad<b-";
const char melody5[] PROGMEM = "! O3 T40 f.b.f.b.f.b.f.b.";
 
// Define global variables for use in the ISRs
// Button related variables
volatile bool button_up_pressed = FALSE;
volatile bool button_down_pressed = FALSE;
volatile bool button_left_pressed = FALSE;
volatile bool button_right_pressed = FALSE;
volatile bool start_button_pressed = FALSE;

// Buzzer related global variables
volatile unsigned char buzzerFinished = 0;	// flag: 0 while playing
const char *buzzerSequence;

// ADC related global variables 
// By default ports are assigned as follows:
//		GyroX = CM-510 Port3 = ADC3 = PORTF3
//		GyroY = CM-510 Port4 = ADC4 = PORTF4
//		DMS   = CM-510 Port5 = ADC5 = PORTF5
//		AccelY= CM-510 Port1 = ADC1 = PORTF0
//		AccelX= CM-510 Port2 = ADC2 = PORTF1
//		Ultra = CM-510 Port6 = ADC6 = PORTF5
volatile uint8 adc_sensor_enable[ADC_CHANNELS] = {1, 1, 1, 1, 1, 1}; 
volatile int16 adc_sensor_val[ADC_CHANNELS] = {0, 0, 0, 0, 0, 0}; 	// array of sensor values
volatile uint16 adc_battery_val = 0;	// battery voltage in millivolts
volatile uint16 adc_gyrox_center = 0;	// gyro x center value
volatile uint16 adc_gyroy_center = 0;	// gyro y center value
volatile int16 adc_accelx = 0;			// accelerometer x value
volatile int16 adc_accely = 0;			// accelerometer y value
volatile uint16 adc_accelx_center = 0;	// accelerometer x center value
volatile uint16 adc_accely_center = 0;	// accelerometer y center value
volatile uint16 adc_ultrasonic_distance = 0;	// ultrasonic distance sensor value
volatile uint16 adc_dms_distance = 0;   // DMS sensor distance value

// Global variables related to the finite state machine that governs execution
volatile uint8 bioloid_command = 0;			// current command
volatile uint8 last_bioloid_command = 0;	// last command
volatile bool  new_command = FALSE;			// flag that we got a new command
volatile uint8 flag_receive_ready = 0;		// received complete command flag

// keep the current pose and joint offsets as global variables
volatile int16 current_pose[NUM_AX12_SERVOS];
volatile int16 joint_offset[NUM_AX12_SERVOS];
// and also the current and next motion pages
volatile uint8 current_motion_page = 0;
volatile uint8 next_motion_page = 0;		// next motion page if we got new command
volatile uint8 current_step = 0;			// number of the current motion page step


// the new implementation of AVR libc does not allow variables passed to _delay_ms
static inline void delay_ms(uint16 count) {
	while(count--) { 
		_delay_ms(1); 
	} 
}


int main(void)
{
	// local variables
	int	sensor_flag, command_flag, comm_status, sensor_process_flag, obstacle_flag;
	// TIMING: unsigned long timer1, timer2, timer3, timer4;
	
	// Initialization Routines
	led_init();				// switches all 6 LEDs on
	serial_init(57600);		// serial port at 57600 baud
	buzzer_init();			// enable buzzer melodies
	button_init();			// enable push buttons on CM-510
	delay_ms(200);			// wait 0.2s 
	led_off(ALL_LED);		// and switch them back off
	
	// initialize the clock
	clock_init();
	
	// enable interrupts
	sei();
	// print welcome message
	printf("\n C.I.T.I.C. Bioloid C Control V 1\n");
	// reset the start button variable, something triggers the interrupt on start-up
	start_button_pressed = FALSE;
	
	// initialize motion pages
	motionPageInit();
	
	// Wait for the START Button before going any further
	while(!start_button_pressed)
	{
		// PLAY LED is flashing at 5Hz
		led_toggle(LED_PLAY);
		delay_ms(200);
	}
	// Now turn LED solid
	led_on(LED_PLAY);
	// and reset the start button variable
	start_button_pressed = FALSE;

	// perform high level initialization of Dynamixel bus and servos
	dxl_init(DEFAULT_BAUDNUMBER);

	// assume initial pose
	executeMotion(COMMAND_BALANCE_MP);
	
	// set the walk state
	walk_setWalkState(0);
	obstacle_flag = 0;

	// initialize the ADC and take default readings
	delay_ms(4000);			// wait 4s for gyros to stabilize
	adc_init();

	// print out default sensor values
	printf("Bateria, Gyro X, Y Accel X, Y Center = %i %i %i %i %i \n", adc_battery_val, adc_gyrox_center, adc_gyroy_center, adc_accelx_center, adc_accely_center);
	
	// write out the command prompt
	printf(	"\nListo para Recibir comandos.\n> ");

	// TIMING: timer4 = micros();

	// main command loop (takes 28us when idle)
	
	command_flag=0;
	command_flag = sendCommand("WFWD");	
    while(1)
    {
		// Check if we received a new command
		//command_flag = serialReceiveCommand();		// takes 4ms if new command (largely because of printf)
		
        
		
		// TIMING: timer1 = micros() - timer4;
		
		// check if start button has been pressed and we need to do emergency stop
		if ( start_button_pressed && bioloid_command != COMMAND_STOP )
		{
			
			// disable torque & reset current command
			comm_status = dxl_write_byte(BROADCAST_ID, DXL_TORQUE_ENABLE, 0);
			last_bioloid_command = bioloid_command;
			bioloid_command = COMMAND_STOP;
			command_flag = 1;
			
			// and reset the start button variable
			start_button_pressed = FALSE;
		} else if ( start_button_pressed && bioloid_command == COMMAND_STOP ) {
			// we are resuming from an emergency stop, restore last command
			bioloid_command = last_bioloid_command;
			last_bioloid_command = COMMAND_STOP;
			command_flag = 1;
			// and reset the start button variable
			start_button_pressed = FALSE;
		}
		
		// Check if we need to read the sensors 
		sensor_flag = adc_readSensors();      // takes 0.6ms for gyro/accel and 0.9ms including DMS/ultrasonic (156us per channel)
		if ( sensor_flag == 1 ) {
			// new sensor data - process and update command flag if necessary
			sensor_process_flag = adc_processSensorData();
			if ( command_flag == 0 && sensor_process_flag == 1 ) {
				command_flag = 1;
			}
		}
		
		// obstacle avoidance for walking
		if ( walk_getWalkState() != 0 ) {
			// currently very basic - turn left until path is clear
			obstacle_flag = walk_avoidObstacle(obstacle_flag);
			if ( command_flag == 0 && (obstacle_flag == 1 || obstacle_flag == -1) ) {
				command_flag = 1;
			}
		}
		
		// set the new command global variable
		if( command_flag == 1 ) {
			new_command = TRUE;
			command_flag = 0;
		}
		// TEST: printf("\n Command %i, New %i, MP %i, Next MP %i ", bioloid_command, new_command, current_motion_page, next_motion_page);
		
		// TIMING: timer2 = micros() - timer4 - timer1;
		
		// execute motion steps
		executeMotionSequence();	// takes 2.1ms when executing a step during walking or 3.3ms if unpacking a new motion page
		
		// TIMING: timer3 = micros() - timer4 - timer1 - timer2;
		// TIMING: printf("%lu, %lu, %lu, %i\n", timer1, timer2, timer3, sensor_flag);
		// TIMING: timer4 = micros();

    } // end of main command loop

}

// There is a bug in the GCC tool chain with AVR Studio 5 (gcc 4.5.1) that causes Flash memory beyond
// 64KB not to be accessed correctly (compiler generates lpm instructions where elpm should be generated)
// for details on this bug see http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&t=108702
// The code below provides a fix

 void __do_copy_data(void) __attribute__((__section__(".init4"), __naked__)); 
  void __do_copy_data(void) { 
    __asm__( 
   "   ldi r17, hi8(__data_end)                                                 \n" 
   "   ldi r26, lo8(__data_start)                                               \n" 
   "   ldi r27, hi8(__data_start)                                               \n" 
   "   ldi r30, lo8(__data_load_start)                                          \n" 
   "   ldi r31, hi8(__data_load_start)                                          \n" 
   "                                                                            \n" 
   "                                                                            \n" 
   "   ldi r16, hh8(__data_load_start)                                          \n" 
   "   out %[_RAMPZ], r16														\n" 
   "   rjmp  .L__do_copy_data_start                                             \n" 
   " .L__do_copy_data_loop:                                                     \n" 
   "   elpm  r0, Z+                                                             \n" 
   "   st  X+, r0                                                               \n" 
   " .L__do_copy_data_start:                                                    \n" 
   "   cpi r26, lo8(__data_end)                                                 \n" 
   "   cpc r27, r17                                                             \n" 
   "   brne  .L__do_copy_data_loop                                              \n" 
   : 
   :  [_RAMPZ]    "I" (_SFR_IO_ADDR(RAMPZ)) 
    ); 
  } 